-- Working with date and time
SELECT NOW(), CURRENT_TIMESTAMP;
SHOW timezone;
SELECT * from pg_timezone_names;
SELECT NOW() at time zone 'Europe/Moscow';
select NOW()::date;
SELECT CURRENT_DATE, NOW()::date;

--Давайте узнаем, сколько сейчас времени в другом регионе, например в Лос-Анджелесе.
--Напишите запрос, который выведет текущие время и дату в часовом поясе Лос-Анджелеса ("America/Los_Angeles").
--Столбец в выдаче — now (время и дата в нужном часовом поясе).
select now() at time zone 'America/Los_Angeles'


--Предположим, у нас есть дата и время какого-то события и мы хотим посмотреть, к какой дате оно относится для Москвы и для UTC.
--Используйте подзапрос
--with x as
--(
--select '2018-12-31 21:00:00+00'::timestamp with time zone ts
--)
--и выведите дату в ts в Московском часовом поясе и в поясе UTC.
--Столбцы в выдаче: dt_msk (дата в московском часовом поясе), dt_utc (дата в UTC).

WITH x AS
(
SELECT '2018-12-31 21:00:00+00'::timestamp WITH time zone ts
)
SELECT
        (ts at time zone 'Europe/Moscow')::date dt_msk,
        (ts)::date dt_utc
FROM x

--EXTRACT
Функция extract() возвращает значения типа double precision.
--!
--DAY
--Для значений timestamp это день месяца (1-31), для значений interval — число дней.
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 16
SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
--Результат: 40
--!
--HOUR
--Час (0-23).
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 20
--!
--MONTH
--Номер месяца, считая с января (1) до декабря (12).
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 2
--!
--YEAR
--Поле года. Учтите, что года 0 не было, и это следует иметь в виду, вычитая из годов нашей эры годы до нашей эры.
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 2001
--!
--ISOYEAR
--Год по недельному календарю ISO 8601, в который попадает дата (не применимо к интервалам).
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
--Результат: 2005
SELECT EXTRACT(DOW FROM DATE '2006-01-01');
--Потому что воскресенье - 0
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
--Результат: 2006
--Год по недельному календарю ISO начинается с понедельника недели, в которой оказывается 4 января, так что в начале января
--или в конце декабря год по ISO может отличаться от года по григорианскому календарю.
--Подробнее об этом рассказывается в описании поля week.
--!
--WEEK
--Номер недели в году по недельному календарю ISO 8601.
--По определению, недели ISO 8601 начинаются с понедельника, а первая неделя года включает 4 января этого года.
--Другими словами, первый четверг года всегда оказывается в первой неделе этого года.
--В системе нумерации недель ISO первые числа января могут относиться к 52-й или 53-й неделе предыдущего года,
--а последние числа декабря — к первой неделе следующего года.
--Например, 2005-01-01 относится к 53-й неделе 2004 г., а 2006-01-01 — к 52-й неделе 2005 г.,
--тогда как 2012-12-31 включается в первую неделю 2013 г.
--Поэтому для получения согласованных результатов рекомендуется использовать поле isoyear в паре с week.
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 7
SELECT EXTRACT(WEEK FROM TIMESTAMP '2005-01-01 20:38:40');
--Результат: 53
SELECT EXTRACT(WEEK FROM TIMESTAMP '2006-01-01 20:38:40');
--Результат: 52
SELECT EXTRACT(WEEK FROM TIMESTAMP '2012-12-31 20:38:40');
--Результат: 1
--!
--CENTURY
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
--Результат: 20
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 21
--Первый век начался 0001-01-01 00:00:00, хотя люди в то время так и не считали.
--Это определение распространяется на все страны с григорианским календарём.
--Века с номером 0 не было; считается, что 1 наступил после -1.
--!
--DECADE
--Десятилетие.
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 200
--!
--EPOCH
--Для значений timestamp with time zone это число секунд с 1970-01-01 00:00:00 UTC (может быть отрицательным);
--для значений date и timestamp это число секунд с 1970-01-01 00:00:00 по местному времени,
--а для interval — общая длительность интервала в секундах.
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
--Результат: 982384720.12
SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
--Результат: 442800
--Преобразовать время эпохи обратно, в значение дата/время, с помощью to_timestamp можно так:
SELECT to_timestamp(982384720.12);
--Результат: 2001-02-17 04:38:40.12+00
--!
--DOW
--День недели, считая с воскресенья (0) до субботы (6).
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 5
--Заметьте, что в extract() дни недели нумеруются не так, как в функции to_char(..., 'D').
--!
--DOY
--День года (1-365/366).
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
--Результат: 47
--!
--ISODOW
--День недели, считая с понедельника (1) до воскресенья (7).
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
--Результат: 7
--Результат отличается от dow только для воскресенья. Такая нумерация соответствует ISO 8601.

--Давайте посчитаем помесячную статистику по доставкам, используя функцию extract().
--Напишите запрос, который выведет год, месяц и количество доставок.
--Отсортируйте по году и по месяцу в порядке возрастания.
--Столбцы в выдаче: year_n (номер года), month_n (номер месяца), qty (количество доставок).
select
    extract(YEAR FROM s.ship_date) year_n,
    extract(MONTH from s.ship_date) month_n,
    count(s.ship_id) qty
from sql.shipment s
group by year_n, month_n
order by year_n asc, month_n asc

--to_char(timestamp[date],text):	преобразует время в текст	to_char(current_timestamp, 'HH12:MI:SS')
--to_char(interval, text):	     преобразует интервал в текст	to_char(interval '15h 2m 12s', 'HH24:MI:SS')
select to_char(now(), 'DDD')
select to_char(current_timestamp, 'HH12:MI:SS DD.MM.YYYY')
select to_char(interval '15h 2m 12s', 'HH24:MI:SS')

--Давайте выведем текст текущего времени для сервиса точного времени.
--Напишите запрос, который выводит текст "Точное время x часов y минут z секунд" (текст в кавычки заключать не нужно),
--где x, y, z — часы, минуты и секунды соответственно, при условии, что сообщение нужно вывести для московского часового пояса.
--Время введите в 24-часовом формате.
--Столбцы в выдаче: msg (сообщение).
select to_char(now() at time zone 'Europe/Moscow', 'Точное время HH24 часов MI минут SS секунд') msg;

--Функция date_trunc() позволяет отсечь заданное время, дату или дату со временем до нужной точности.
--Например, если мы хотим округлить текущее время-дату до минут, то можно вызвать
select date_trunc('minute',now())

--Давайте подготовим данные для квартальной отчётности компании.
--Напишите запрос, который выведет дату доставки, округлённую до квартала, и общую массу доставок.
--Отсортируйте по кварталу в порядке возрастания.
--Столбцы в выдаче: q (начало квартала, тип date), total_weight (сумма масс доставок за квартал).
select
    to_char(date_trunc('quarter', s.ship_date), 'DD.MM.YYYY') q,
    sum(s.weight) total_weight
from sql.shipment s
group by q

select
    date_trunc('quarter', s.ship_date)::date q,
    sum(s.weight) total_weight
from sql.shipment s
group by q
order by q asc

--К любой дате можно прибавить (и вычесть из неё) целое число X и получить другую дату, которая больше (меньше) изначальной.
--Пример:
select '2019-01-01'::date + 10
--Результат: '2019-01-11'
--Это — дата на 10 дней позже 2019-01-01.
--
--При добавлении (или вычитании) целого числа к дате Postgres учитывает переходы между месяцами и годами и даёт верный ответ,
--соответствующий календарю. Учитываются даже високосные годы.
--Пример:
select '2019-01-01'::date + 500
--Результат: '2020-05-15'
--Как видим, сменились и год, и месяц, и день.
--
--Аналогично можно вычесть из одной даты другую и получить расстояние в днях между этими датами.
--При такой операции тоже будет честная разница по календарю.
--Пример:
select '2019-02-10'::date - '2017-03-01'::date
--Результат: 711

--Давайте оценим, в каком интервале совершались доставки в разных городах.
--Напишите запрос, который выведет разницу между последним и первым днём доставки по каждому городу.
--Отсортируйте по первому и второму столбцам.
--Столбцы в выдаче: city_name (название города) и days_active (время от первой до последней доставки в днях).
select
    c.city_name city_name,
    max(s.ship_date)::date - min(s.ship_date) days_active
from sql.shipment s
join sql.city c on c.city_id = s.city_id
group by city_name
order by city_name, days_active asc

select max(s.ship_date) from sql.shipment s